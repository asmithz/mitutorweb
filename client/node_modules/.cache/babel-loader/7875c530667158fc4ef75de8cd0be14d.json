{"ast":null,"code":"import { MS_PER_HOUR, MS_PER_MINUTE, ZonedDate } from '@progress/kendo-date-math';\nimport { DailyFrequency, HourlyFrequency, MonthlyFrequency, WeeklyFrequency, YearlyFrequency } from './frequencies';\nimport { duration, setDayOfWeek } from './utils';\nvar frequencies = {\n  'hourly': new HourlyFrequency(),\n  'daily': new DailyFrequency(),\n  'weekly': new WeeklyFrequency(),\n  'monthly': new MonthlyFrequency(),\n  'yearly': new YearlyFrequency()\n}; // Normally, ZonedDate will allow creating an instance at the\n// missing DST hour in the time zone.\n// This is useful during recurrence calculations.\n//\n// By doing a round-trip through toLocalDate(), the missing\n// DST hour is replaced with a valid time.\n\nvar normalizeDST = function (date) {\n  return ZonedDate.fromLocalDate(date.toLocalDate(), date.timezone);\n};\n\nvar getTimeAfterMidnight = function (date) {\n  return date.getHours() * MS_PER_HOUR + date.getMinutes() * MS_PER_MINUTE + date.getSeconds() * 1000 + date.getMilliseconds();\n};\n\nvar isException = function (exceptions, date) {\n  if (!exceptions) {\n    return false;\n  }\n\n  var dateTime = date.getTime() - date.getMilliseconds();\n  var length = exceptions.length;\n\n  for (var idx = 0; idx < length; idx++) {\n    if (exceptions[idx].getTime() === dateTime) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nvar startPeriodByFreq = function (start, rule) {\n  var date = start.toUTCDate();\n\n  switch (rule.freq) {\n    case 'yearly':\n      date.setUTCFullYear(date.getFullYear(), 0, 1);\n      break;\n\n    case 'monthly':\n      date.setUTCFullYear(date.getFullYear(), date.getMonth(), 1);\n      break;\n\n    case 'weekly':\n      setDayOfWeek(date, rule.weekStart, -1);\n      break;\n\n    default:\n      break;\n  }\n\n  if (rule.byHour) {\n    date.setUTCHours(0);\n  }\n\n  if (rule.byMinute) {\n    date.setUTCMinutes(0);\n  }\n\n  if (rule.bySecond) {\n    date.setUTCSeconds(0);\n  }\n\n  return ZonedDate.fromUTCDate(date, start.timezone);\n};\n\nvar endPeriodByFreq = function (start, rule) {\n  var date = start.toUTCDate();\n\n  switch (rule.freq) {\n    case 'yearly':\n      date.setUTCFullYear(date.getUTCFullYear(), 11, 31);\n      break;\n\n    case 'monthly':\n      date.setUTCFullYear(date.getUTCFullYear(), date.getUTCMonth() + 1, 0);\n      break;\n\n    case 'weekly':\n      setDayOfWeek(date, rule.weekStart, -1);\n      date.setUTCDate(date.getUTCDate() + 6);\n      break;\n\n    default:\n      break;\n  }\n\n  if (rule.byHour) {\n    date.setUTCHours(23);\n  }\n\n  if (rule.byMinute) {\n    date.setUTCMinutes(59);\n  }\n\n  if (rule.bySecond) {\n    date.setUTCSeconds(59);\n  }\n\n  return ZonedDate.fromUTCDate(date, start.timezone);\n};\n\nvar eventsByPosition = function (periodEvents, start, positions) {\n  var periodEventsLength = periodEvents.length;\n  var events = [];\n  var position;\n\n  for (var idx = 0, length_1 = positions.length; idx < length_1; idx++) {\n    position = positions[idx];\n\n    if (position < 0) {\n      position = periodEventsLength + position;\n    } else {\n      position -= 1; //convert to zero based index\n    }\n\n    var event_1 = periodEvents[position];\n\n    if (event_1 && event_1.start >= start) {\n      events.push(event_1);\n    }\n  }\n\n  return events;\n};\n\nvar removeExceptionDates = function (periodEvents, exceptionDates) {\n  var events = [];\n\n  for (var idx = 0; idx < periodEvents.length; idx++) {\n    var event_2 = periodEvents[idx];\n\n    if (event_2 && !isException(exceptionDates, event_2.start)) {\n      events.push(event_2);\n    }\n  }\n\n  return events;\n};\n/**\n * Expands a recurrence rule into individual events in the specified time range.\n *\n * @param rule The recurrence rule to expand.\n * @param options Configuration options for the expand operation.\n * @return ExpandResult The result of the operation. If successful, the events field will contain the events.\n */\n\n\nexport function expand(rule, options) {\n  var rangeStart = options.rangeStart,\n      rangeEnd = options.rangeEnd;\n\n  if (!rule) {\n    return {\n      success: true,\n      errorMessage: '',\n      events: []\n    };\n  }\n\n  var freqName = rule.freq;\n  var freq = frequencies[freqName];\n  var eventStart = rule.start;\n  var eventDuration = duration(rule.start, rule.end);\n  var endPeriod;\n\n  if (rule.start.getTime() > rule.end.getTime()) {\n    return {\n      success: false,\n      errorMessage: \"Invalid recurrence rule: Start date (\" + rule.start + \")\" + (\"is greater than End date \" + rule.start),\n      events: []\n    };\n  }\n\n  if (!freq) {\n    return {\n      success: false,\n      errorMessage: \"Invalid recurrence frequency \\\"\" + freqName + \"\\\"\",\n      events: []\n    };\n  }\n\n  var events = [];\n  var positions = rule.bySetPosition;\n  var currentIdx = positions ? 0 : 1;\n  var exceptionDates = rule.exceptionDates;\n  var start = rangeStart.toTimezone(eventStart.timezone);\n  var startPeriod = start;\n  var end = rangeEnd.toTimezone(eventStart.timezone);\n  var count = rule.count;\n\n  if (rule.until && rule.until.getTime() < end.getTime()) {\n    end = rule.until.clone();\n  }\n\n  var hours = start.getHours();\n  var minutes = start.getMinutes();\n  var seconds = start.getSeconds();\n  var useEventStart = freqName === 'yearly' || freqName === 'monthly' || freqName === 'weekly';\n\n  if (start.getTime() < eventStart.getTime() || count || rule.interval > 1 || useEventStart) {\n    start = eventStart.clone();\n  } else {\n    if (!rule.byHour) {\n      hours = eventStart.getHours();\n    }\n\n    if (!rule.byMinute) {\n      minutes = eventStart.getMinutes();\n    }\n\n    if (!rule.bySecond) {\n      seconds = eventStart.getSeconds();\n    }\n\n    var startAdj = start.toUTCDate();\n    startAdj.setUTCHours(hours, minutes, seconds, eventStart.getMilliseconds());\n    start = ZonedDate.fromUTCDate(startAdj, start.timezone);\n  }\n\n  rule._startPeriod = start.clone();\n\n  if (positions) {\n    start = startPeriodByFreq(start, rule);\n    end = endPeriodByFreq(end, rule);\n    var diff = getTimeAfterMidnight(end) - getTimeAfterMidnight(start);\n\n    if (diff < 0) {\n      var endAdj = end.toUTCDate();\n      endAdj.setUTCHours(start.getHours(), start.getMinutes(), start.getSeconds(), start.getMilliseconds());\n      end = ZonedDate.fromUTCDate(endAdj, end.timezone);\n    }\n\n    rule._startPeriod = start.clone();\n    endPeriod = endPeriodByFreq(start, rule);\n  }\n\n  var startTime = getTimeAfterMidnight(start);\n  rule._startTime = new Date(startTime);\n  var next = start.toUTCDate();\n\n  if (freq.setup) {\n    freq.setup(rule, eventStart, next);\n    start = ZonedDate.fromUTCDate(next, start.timezone);\n  }\n\n  next = start.toUTCDate();\n  freq.limit(next, end.toUTCDate(), rule);\n  start = ZonedDate.fromUTCDate(next, start.timezone);\n\n  while (start <= end) {\n    var endDate = start.addTime(eventDuration);\n    var inPeriod = start >= startPeriod || endDate > startPeriod;\n\n    if (inPeriod && !isException(exceptionDates, start) || positions) {\n      events.push({\n        start: normalizeDST(start),\n        end: normalizeDST(endDate)\n      });\n\n      if (freqName === 'hourly' || freqName === 'minutely' || freqName === 'secondly') {\n        // Use the DST-adjusted time to maintain duration between occurrences\n        startTime = getTimeAfterMidnight(normalizeDST(start));\n        rule._startTime = new Date(startTime);\n      }\n    }\n\n    if (positions) {\n      next = start.toUTCDate();\n      freq.next(next, rule);\n      freq.limit(next, end.toUTCDate(), rule);\n      start = ZonedDate.fromUTCDate(next, start.timezone);\n\n      if (start > endPeriod) {\n        var periodEvents = eventsByPosition(events.slice(currentIdx), eventStart, positions);\n        periodEvents = removeExceptionDates(periodEvents, exceptionDates);\n        events = events.slice(0, currentIdx).concat(periodEvents);\n        endPeriod = endPeriodByFreq(start, rule);\n        currentIdx = events.length;\n      }\n\n      if (count && count === currentIdx) {\n        break;\n      }\n    } else {\n      if (count && count === currentIdx) {\n        break;\n      }\n\n      currentIdx += 1;\n      next = start.toUTCDate();\n      freq.next(next, rule);\n      freq.limit(next, end.toUTCDate(), rule);\n      start = ZonedDate.fromUTCDate(next, start.timezone);\n    }\n  }\n\n  return {\n    success: true,\n    errorMessage: '',\n    events: events\n  };\n}","map":{"version":3,"sources":["/home/asmith/taller/proyecto1/proyecto-taller/client/node_modules/@progress/kendo-recurrence/dist/es/expand.js"],"names":["MS_PER_HOUR","MS_PER_MINUTE","ZonedDate","DailyFrequency","HourlyFrequency","MonthlyFrequency","WeeklyFrequency","YearlyFrequency","duration","setDayOfWeek","frequencies","normalizeDST","date","fromLocalDate","toLocalDate","timezone","getTimeAfterMidnight","getHours","getMinutes","getSeconds","getMilliseconds","isException","exceptions","dateTime","getTime","length","idx","startPeriodByFreq","start","rule","toUTCDate","freq","setUTCFullYear","getFullYear","getMonth","weekStart","byHour","setUTCHours","byMinute","setUTCMinutes","bySecond","setUTCSeconds","fromUTCDate","endPeriodByFreq","getUTCFullYear","getUTCMonth","setUTCDate","getUTCDate","eventsByPosition","periodEvents","positions","periodEventsLength","events","position","length_1","event_1","push","removeExceptionDates","exceptionDates","event_2","expand","options","rangeStart","rangeEnd","success","errorMessage","freqName","eventStart","eventDuration","end","endPeriod","bySetPosition","currentIdx","toTimezone","startPeriod","count","until","clone","hours","minutes","seconds","useEventStart","interval","startAdj","_startPeriod","diff","endAdj","startTime","_startTime","Date","next","setup","limit","endDate","addTime","inPeriod","slice","concat"],"mappings":"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","sourcesContent":["import { MS_PER_HOUR, MS_PER_MINUTE, ZonedDate } from '@progress/kendo-date-math';\nimport { DailyFrequency, HourlyFrequency, MonthlyFrequency, WeeklyFrequency, YearlyFrequency } from './frequencies';\nimport { duration, setDayOfWeek } from './utils';\nvar frequencies = {\n    'hourly': new HourlyFrequency(),\n    'daily': new DailyFrequency(),\n    'weekly': new WeeklyFrequency(),\n    'monthly': new MonthlyFrequency(),\n    'yearly': new YearlyFrequency()\n};\n// Normally, ZonedDate will allow creating an instance at the\n// missing DST hour in the time zone.\n// This is useful during recurrence calculations.\n//\n// By doing a round-trip through toLocalDate(), the missing\n// DST hour is replaced with a valid time.\nvar normalizeDST = function (date) {\n    return ZonedDate.fromLocalDate(date.toLocalDate(), date.timezone);\n};\nvar getTimeAfterMidnight = function (date) {\n    return date.getHours() * MS_PER_HOUR +\n        date.getMinutes() * MS_PER_MINUTE +\n        date.getSeconds() * 1000 +\n        date.getMilliseconds();\n};\nvar isException = function (exceptions, date) {\n    if (!exceptions) {\n        return false;\n    }\n    var dateTime = date.getTime() - date.getMilliseconds();\n    var length = exceptions.length;\n    for (var idx = 0; idx < length; idx++) {\n        if (exceptions[idx].getTime() === dateTime) {\n            return true;\n        }\n    }\n    return false;\n};\nvar startPeriodByFreq = function (start, rule) {\n    var date = start.toUTCDate();\n    switch (rule.freq) {\n        case 'yearly':\n            date.setUTCFullYear(date.getFullYear(), 0, 1);\n            break;\n        case 'monthly':\n            date.setUTCFullYear(date.getFullYear(), date.getMonth(), 1);\n            break;\n        case 'weekly':\n            setDayOfWeek(date, rule.weekStart, -1);\n            break;\n        default:\n            break;\n    }\n    if (rule.byHour) {\n        date.setUTCHours(0);\n    }\n    if (rule.byMinute) {\n        date.setUTCMinutes(0);\n    }\n    if (rule.bySecond) {\n        date.setUTCSeconds(0);\n    }\n    return ZonedDate.fromUTCDate(date, start.timezone);\n};\nvar endPeriodByFreq = function (start, rule) {\n    var date = start.toUTCDate();\n    switch (rule.freq) {\n        case 'yearly':\n            date.setUTCFullYear(date.getUTCFullYear(), 11, 31);\n            break;\n        case 'monthly':\n            date.setUTCFullYear(date.getUTCFullYear(), date.getUTCMonth() + 1, 0);\n            break;\n        case 'weekly':\n            setDayOfWeek(date, rule.weekStart, -1);\n            date.setUTCDate(date.getUTCDate() + 6);\n            break;\n        default:\n            break;\n    }\n    if (rule.byHour) {\n        date.setUTCHours(23);\n    }\n    if (rule.byMinute) {\n        date.setUTCMinutes(59);\n    }\n    if (rule.bySecond) {\n        date.setUTCSeconds(59);\n    }\n    return ZonedDate.fromUTCDate(date, start.timezone);\n};\nvar eventsByPosition = function (periodEvents, start, positions) {\n    var periodEventsLength = periodEvents.length;\n    var events = [];\n    var position;\n    for (var idx = 0, length_1 = positions.length; idx < length_1; idx++) {\n        position = positions[idx];\n        if (position < 0) {\n            position = periodEventsLength + position;\n        }\n        else {\n            position -= 1; //convert to zero based index\n        }\n        var event_1 = periodEvents[position];\n        if (event_1 && event_1.start >= start) {\n            events.push(event_1);\n        }\n    }\n    return events;\n};\nvar removeExceptionDates = function (periodEvents, exceptionDates) {\n    var events = [];\n    for (var idx = 0; idx < periodEvents.length; idx++) {\n        var event_2 = periodEvents[idx];\n        if (event_2 && !isException(exceptionDates, event_2.start)) {\n            events.push(event_2);\n        }\n    }\n    return events;\n};\n/**\n * Expands a recurrence rule into individual events in the specified time range.\n *\n * @param rule The recurrence rule to expand.\n * @param options Configuration options for the expand operation.\n * @return ExpandResult The result of the operation. If successful, the events field will contain the events.\n */\nexport function expand(rule, options) {\n    var rangeStart = options.rangeStart, rangeEnd = options.rangeEnd;\n    if (!rule) {\n        return {\n            success: true,\n            errorMessage: '',\n            events: []\n        };\n    }\n    var freqName = rule.freq;\n    var freq = frequencies[freqName];\n    var eventStart = rule.start;\n    var eventDuration = duration(rule.start, rule.end);\n    var endPeriod;\n    if (rule.start.getTime() > rule.end.getTime()) {\n        return {\n            success: false,\n            errorMessage: \"Invalid recurrence rule: Start date (\" + rule.start + \")\" +\n                (\"is greater than End date \" + rule.start),\n            events: []\n        };\n    }\n    if (!freq) {\n        return {\n            success: false,\n            errorMessage: \"Invalid recurrence frequency \\\"\" + freqName + \"\\\"\",\n            events: []\n        };\n    }\n    var events = [];\n    var positions = rule.bySetPosition;\n    var currentIdx = positions ? 0 : 1;\n    var exceptionDates = rule.exceptionDates;\n    var start = rangeStart.toTimezone(eventStart.timezone);\n    var startPeriod = start;\n    var end = rangeEnd.toTimezone(eventStart.timezone);\n    var count = rule.count;\n    if (rule.until && rule.until.getTime() < end.getTime()) {\n        end = rule.until.clone();\n    }\n    var hours = start.getHours();\n    var minutes = start.getMinutes();\n    var seconds = start.getSeconds();\n    var useEventStart = freqName === 'yearly' || freqName === 'monthly' || freqName === 'weekly';\n    if (start.getTime() < eventStart.getTime() || count || rule.interval > 1 || useEventStart) {\n        start = eventStart.clone();\n    }\n    else {\n        if (!rule.byHour) {\n            hours = eventStart.getHours();\n        }\n        if (!rule.byMinute) {\n            minutes = eventStart.getMinutes();\n        }\n        if (!rule.bySecond) {\n            seconds = eventStart.getSeconds();\n        }\n        var startAdj = start.toUTCDate();\n        startAdj.setUTCHours(hours, minutes, seconds, eventStart.getMilliseconds());\n        start = ZonedDate.fromUTCDate(startAdj, start.timezone);\n    }\n    rule._startPeriod = start.clone();\n    if (positions) {\n        start = startPeriodByFreq(start, rule);\n        end = endPeriodByFreq(end, rule);\n        var diff = getTimeAfterMidnight(end) - getTimeAfterMidnight(start);\n        if (diff < 0) {\n            var endAdj = end.toUTCDate();\n            endAdj.setUTCHours(start.getHours(), start.getMinutes(), start.getSeconds(), start.getMilliseconds());\n            end = ZonedDate.fromUTCDate(endAdj, end.timezone);\n        }\n        rule._startPeriod = start.clone();\n        endPeriod = endPeriodByFreq(start, rule);\n    }\n    var startTime = getTimeAfterMidnight(start);\n    rule._startTime = new Date(startTime);\n    var next = start.toUTCDate();\n    if (freq.setup) {\n        freq.setup(rule, eventStart, next);\n        start = ZonedDate.fromUTCDate(next, start.timezone);\n    }\n    next = start.toUTCDate();\n    freq.limit(next, end.toUTCDate(), rule);\n    start = ZonedDate.fromUTCDate(next, start.timezone);\n    while (start <= end) {\n        var endDate = start.addTime(eventDuration);\n        var inPeriod = start >= startPeriod || endDate > startPeriod;\n        if (inPeriod && !isException(exceptionDates, start) || positions) {\n            events.push({\n                start: normalizeDST(start),\n                end: normalizeDST(endDate)\n            });\n            if (freqName === 'hourly' || freqName === 'minutely' || freqName === 'secondly') {\n                // Use the DST-adjusted time to maintain duration between occurrences\n                startTime = getTimeAfterMidnight(normalizeDST(start));\n                rule._startTime = new Date(startTime);\n            }\n        }\n        if (positions) {\n            next = start.toUTCDate();\n            freq.next(next, rule);\n            freq.limit(next, end.toUTCDate(), rule);\n            start = ZonedDate.fromUTCDate(next, start.timezone);\n            if (start > endPeriod) {\n                var periodEvents = eventsByPosition(events.slice(currentIdx), eventStart, positions);\n                periodEvents = removeExceptionDates(periodEvents, exceptionDates);\n                events = events.slice(0, currentIdx).concat(periodEvents);\n                endPeriod = endPeriodByFreq(start, rule);\n                currentIdx = events.length;\n            }\n            if (count && count === currentIdx) {\n                break;\n            }\n        }\n        else {\n            if (count && count === currentIdx) {\n                break;\n            }\n            currentIdx += 1;\n            next = start.toUTCDate();\n            freq.next(next, rule);\n            freq.limit(next, end.toUTCDate(), rule);\n            start = ZonedDate.fromUTCDate(next, start.timezone);\n        }\n    }\n    return {\n        success: true,\n        errorMessage: '',\n        events: events\n    };\n}\n"]},"metadata":{},"sourceType":"module"}