{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.preventScroll = exports.GridCell = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _styledComponents = _interopRequireDefault(require(\"styled-components\"));\n\nvar _add_minutes = _interopRequireDefault(require(\"date-fns/add_minutes\"));\n\nvar _add_hours = _interopRequireDefault(require(\"date-fns/add_hours\"));\n\nvar _add_days = _interopRequireDefault(require(\"date-fns/add_days\"));\n\nvar _start_of_day = _interopRequireDefault(require(\"date-fns/start_of_day\"));\n\nvar _is_same_minute = _interopRequireDefault(require(\"date-fns/is_same_minute\"));\n\nvar _format = _interopRequireDefault(require(\"date-fns/format\"));\n\nvar _typography = require(\"./typography\");\n\nvar _colors = _interopRequireDefault(require(\"./colors\"));\n\nvar _selectionSchemes = _interopRequireDefault(require(\"./selection-schemes\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n} // Import only the methods we need from date-fns in order to keep build size small\n\n\nconst Wrapper = _styledComponents.default.div.withConfig({\n  displayName: \"ScheduleSelector__Wrapper\",\n  componentId: \"sc-1ke4ka2-0\"\n})([\"display:flex;align-items:center;width:100%;user-select:none;\"]);\n\nconst Grid = _styledComponents.default.div.withConfig({\n  displayName: \"ScheduleSelector__Grid\",\n  componentId: \"sc-1ke4ka2-1\"\n})([\"display:grid;grid-template-columns:auto repeat(\", \",1fr);grid-template-rows:auto repeat(\", \",1fr);column-gap:\", \";row-gap:\", \";width:100%;\"], props => props.columns, props => props.rows, props => props.columnGap, props => props.rowGap);\n\nconst GridCell = _styledComponents.default.div.withConfig({\n  displayName: \"ScheduleSelector__GridCell\",\n  componentId: \"sc-1ke4ka2-2\"\n})([\"place-self:stretch;touch-action:none;\"]);\n\nexports.GridCell = GridCell;\n\nconst DateCell = _styledComponents.default.div.withConfig({\n  displayName: \"ScheduleSelector__DateCell\",\n  componentId: \"sc-1ke4ka2-3\"\n})([\"width:100%;height:25px;background-color:\", \";&:hover{background-color:\", \";}\"], props => props.selected ? props.selectedColor : props.unselectedColor, props => props.hoveredColor);\n\nconst DateLabel = (0, _styledComponents.default)(_typography.Subtitle).withConfig({\n  displayName: \"ScheduleSelector__DateLabel\",\n  componentId: \"sc-1ke4ka2-4\"\n})([\"@media (max-width:699px){font-size:12px;}margin:0;margin-bottom:4px;\"]);\nconst TimeText = (0, _styledComponents.default)(_typography.Text).withConfig({\n  displayName: \"ScheduleSelector__TimeText\",\n  componentId: \"sc-1ke4ka2-5\"\n})([\"@media (max-width:699px){font-size:10px;}text-align:right;margin:0;margin-right:4px;\"]);\n\nconst preventScroll = e => {\n  e.preventDefault();\n};\n\nexports.preventScroll = preventScroll;\n\nclass ScheduleSelector extends React.Component {\n  // documentMouseUpHandler: () => void = () => {}\n  // endSelection: () => void = () => {}\n  // handleTouchMoveEvent: (event: React.SyntheticTouchEvent<*>) => void\n  // handleTouchEndEvent: () => void\n  // handleMouseUpEvent: (date: Date) => void\n  // handleMouseEnterEvent: (date: Date) => void\n  // handleSelectionStartEvent: (date: Date) => void\n  static getDerivedStateFromProps(props, state) {\n    // As long as the user isn't in the process of selecting, allow prop changes to re-populate selection state\n    if (state.selectionStart == null) {\n      return {\n        selectionDraft: [...props.selection],\n        dates: ScheduleSelector.computeDatesMatrix(props)\n      };\n    }\n\n    return null;\n  }\n\n  static computeDatesMatrix(props) {\n    const startTime = (0, _start_of_day.default)(props.startDate);\n    const dates = [];\n    const minutesInChunk = Math.floor(60 / props.hourlyChunks);\n\n    for (let d = 0; d < props.numDays; d += 1) {\n      const currentDay = [];\n\n      for (let h = props.minTime; h < props.maxTime; h += 1) {\n        for (let c = 0; c < props.hourlyChunks; c += 1) {\n          currentDay.push((0, _add_minutes.default)((0, _add_hours.default)((0, _add_days.default)(startTime, d), h), c * minutesInChunk));\n        }\n      }\n\n      dates.push(currentDay);\n    }\n\n    return dates;\n  }\n\n  constructor(props) {\n    super(props);\n    this.cellToDate = new Map();\n    this.gridRef = null;\n\n    this.renderDateCellWrapper = time => {\n      const startHandler = () => {\n        this.handleSelectionStartEvent(time);\n      };\n\n      const selected = Boolean(this.state.selectionDraft.find(a => (0, _is_same_minute.default)(a, time)));\n      return /*#__PURE__*/React.createElement(GridCell, {\n        className: \"rgdp__grid-cell\",\n        role: \"presentation\",\n        key: time.toISOString() // Mouse handlers\n        ,\n        onMouseDown: startHandler,\n        onMouseEnter: () => {\n          this.handleMouseEnterEvent(time);\n        },\n        onMouseUp: () => {\n          this.handleMouseUpEvent(time);\n        } // Touch handlers\n        // Since touch events fire on the event where the touch-drag started, there's no point in passing\n        // in the time parameter, instead these handlers will do their job using the default Event\n        // parameters\n        ,\n        onTouchStart: startHandler,\n        onTouchMove: this.handleTouchMoveEvent,\n        onTouchEnd: this.handleTouchEndEvent\n      }, this.renderDateCell(time, selected));\n    };\n\n    this.renderDateCell = (time, selected) => {\n      const refSetter = dateCell => {\n        if (dateCell) {\n          this.cellToDate.set(dateCell, time);\n        }\n      };\n\n      if (this.props.renderDateCell) {\n        return this.props.renderDateCell(time, selected, refSetter);\n      } else {\n        return /*#__PURE__*/React.createElement(DateCell, {\n          selected: selected,\n          ref: refSetter,\n          selectedColor: this.props.selectedColor,\n          unselectedColor: this.props.unselectedColor,\n          hoveredColor: this.props.hoveredColor\n        });\n      }\n    };\n\n    this.renderTimeLabel = time => {\n      if (this.props.renderTimeLabel) {\n        return this.props.renderTimeLabel(time);\n      } else {\n        return /*#__PURE__*/React.createElement(TimeText, null, (0, _format.default)(time, this.props.timeFormat));\n      }\n    };\n\n    this.renderDateLabel = date => {\n      if (this.props.renderDateLabel) {\n        return this.props.renderDateLabel(date);\n      } else {\n        return /*#__PURE__*/React.createElement(DateLabel, null, (0, _format.default)(date, this.props.dateFormat));\n      }\n    };\n\n    this.state = {\n      selectionDraft: [...this.props.selection],\n      // copy it over\n      selectionType: null,\n      selectionStart: null,\n      isTouchDragging: false,\n      dates: ScheduleSelector.computeDatesMatrix(props)\n    };\n    this.selectionSchemeHandlers = {\n      linear: _selectionSchemes.default.linear,\n      square: _selectionSchemes.default.square\n    };\n    this.endSelection = this.endSelection.bind(this);\n    this.handleMouseUpEvent = this.handleMouseUpEvent.bind(this);\n    this.handleMouseEnterEvent = this.handleMouseEnterEvent.bind(this);\n    this.handleTouchMoveEvent = this.handleTouchMoveEvent.bind(this);\n    this.handleTouchEndEvent = this.handleTouchEndEvent.bind(this);\n    this.handleSelectionStartEvent = this.handleSelectionStartEvent.bind(this);\n  }\n\n  componentDidMount() {\n    // We need to add the endSelection event listener to the document itself in order\n    // to catch the cases where the users ends their mouse-click somewhere besides\n    // the date cells (in which case none of the DateCell's onMouseUp handlers would fire)\n    //\n    // This isn't necessary for touch events since the `touchend` event fires on\n    // the element where the touch/drag started so it's always caught.\n    document.addEventListener('mouseup', this.endSelection); // Prevent page scrolling when user is dragging on the date cells\n\n    this.cellToDate.forEach((value, dateCell) => {\n      if (dateCell && dateCell.addEventListener) {\n        // @ts-ignore\n        dateCell.addEventListener('touchmove', preventScroll, {\n          passive: false\n        });\n      }\n    });\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('mouseup', this.endSelection);\n    this.cellToDate.forEach((value, dateCell) => {\n      if (dateCell && dateCell.removeEventListener) {\n        // @ts-ignore\n        dateCell.removeEventListener('touchmove', preventScroll);\n      }\n    });\n  } // Performs a lookup into this.cellToDate to retrieve the Date that corresponds to\n  // the cell where this touch event is right now. Note that this method will only work\n  // if the event is a `touchmove` event since it's the only one that has a `touches` list.\n\n\n  getTimeFromTouchEvent(event) {\n    const {\n      touches\n    } = event;\n    if (!touches || touches.length === 0) return null;\n    const {\n      clientX,\n      clientY\n    } = touches[0];\n    const targetElement = document.elementFromPoint(clientX, clientY);\n\n    if (targetElement) {\n      const cellTime = this.cellToDate.get(targetElement);\n      return cellTime !== null && cellTime !== void 0 ? cellTime : null;\n    }\n\n    return null;\n  }\n\n  endSelection() {\n    this.props.onChange(this.state.selectionDraft);\n    this.setState({\n      selectionType: null,\n      selectionStart: null\n    });\n  } // Given an ending Date, determines all the dates that should be selected in this draft\n\n\n  updateAvailabilityDraft(selectionEnd, callback) {\n    const {\n      selectionType,\n      selectionStart\n    } = this.state;\n    if (selectionType === null || selectionStart === null) return;\n    let newSelection = [];\n\n    if (selectionStart && selectionEnd && selectionType) {\n      newSelection = this.selectionSchemeHandlers[this.props.selectionScheme](selectionStart, selectionEnd, this.state.dates);\n    }\n\n    let nextDraft = [...this.props.selection];\n\n    if (selectionType === 'add') {\n      nextDraft = Array.from(new Set([...nextDraft, ...newSelection]));\n    } else if (selectionType === 'remove') {\n      nextDraft = nextDraft.filter(a => !newSelection.find(b => (0, _is_same_minute.default)(a, b)));\n    }\n\n    this.setState({\n      selectionDraft: nextDraft\n    }, callback);\n  } // Isomorphic (mouse and touch) handler since starting a selection works the same way for both classes of user input\n\n\n  handleSelectionStartEvent(startTime) {\n    // Check if the startTime cell is selected/unselected to determine if this drag-select should\n    // add values or remove values\n    const timeSelected = this.props.selection.find(a => (0, _is_same_minute.default)(a, startTime));\n    this.setState({\n      selectionType: timeSelected ? 'remove' : 'add',\n      selectionStart: startTime\n    });\n  }\n\n  handleMouseEnterEvent(time) {\n    // Need to update selection draft on mouseup as well in order to catch the cases\n    // where the user just clicks on a single cell (because no mouseenter events fire\n    // in this scenario)\n    this.updateAvailabilityDraft(time);\n  }\n\n  handleMouseUpEvent(time) {\n    this.updateAvailabilityDraft(time); // Don't call this.endSelection() here because the document mouseup handler will do it\n  }\n\n  handleTouchMoveEvent(event) {\n    this.setState({\n      isTouchDragging: true\n    });\n    const cellTime = this.getTimeFromTouchEvent(event);\n\n    if (cellTime) {\n      this.updateAvailabilityDraft(cellTime);\n    }\n  }\n\n  handleTouchEndEvent() {\n    if (!this.state.isTouchDragging) {\n      // Going down this branch means the user tapped but didn't drag -- which\n      // means the availability draft hasn't yet been updated (since\n      // handleTouchMoveEvent was never called) so we need to do it now\n      this.updateAvailabilityDraft(null, () => {\n        this.endSelection();\n      });\n    } else {\n      this.endSelection();\n    }\n\n    this.setState({\n      isTouchDragging: false\n    });\n  }\n\n  renderFullDateGrid() {\n    const flattenedDates = [];\n    const numDays = this.state.dates.length;\n    const numTimes = this.state.dates[0].length;\n\n    for (let j = 0; j < numTimes; j += 1) {\n      for (let i = 0; i < numDays; i += 1) {\n        flattenedDates.push(this.state.dates[i][j]);\n      }\n    }\n\n    const dateGridElements = flattenedDates.map(this.renderDateCellWrapper);\n\n    for (let i = 0; i < numTimes; i += 1) {\n      const index = i * numDays;\n      const time = this.state.dates[0][i]; // Inject the time label at the start of every row\n\n      dateGridElements.splice(index + i, 0, this.renderTimeLabel(time));\n    }\n\n    return [\n    /*#__PURE__*/\n    // Empty top left corner\n    React.createElement(\"div\", {\n      key: \"topleft\"\n    }), // Top row of dates\n    ...this.state.dates.map((dayOfTimes, index) => /*#__PURE__*/React.cloneElement(this.renderDateLabel(dayOfTimes[0]), {\n      key: \"date-\".concat(index)\n    })), // Every row after that\n    ...dateGridElements.map((element, index) => /*#__PURE__*/React.cloneElement(element, {\n      key: \"time-\".concat(index)\n    }))];\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(Wrapper, null, /*#__PURE__*/React.createElement(Grid, {\n      columns: this.state.dates.length,\n      rows: this.state.dates[0].length,\n      columnGap: this.props.columnGap,\n      rowGap: this.props.rowGap,\n      ref: el => {\n        this.gridRef = el;\n      }\n    }, this.renderFullDateGrid()));\n  }\n\n}\n\nexports.default = ScheduleSelector;\nScheduleSelector.defaultProps = {\n  selection: [],\n  selectionScheme: 'square',\n  numDays: 7,\n  minTime: 9,\n  maxTime: 23,\n  hourlyChunks: 1,\n  startDate: new Date(),\n  timeFormat: 'ha',\n  dateFormat: 'M/D',\n  columnGap: '4px',\n  rowGap: '4px',\n  selectedColor: _colors.default.blue,\n  unselectedColor: _colors.default.paleBlue,\n  hoveredColor: _colors.default.lightBlue,\n  onChange: () => {}\n};","map":{"version":3,"sources":["../../src/lib/ScheduleSelector.tsx"],"names":["Wrapper","styled","Grid","props","GridCell","DateCell","DateLabel","Subtitle","TimeText","Text","preventScroll","e","ScheduleSelector","React","cellToDate","gridRef","defaultProps","selection","selectionScheme","numDays","minTime","maxTime","hourlyChunks","startDate","timeFormat","dateFormat","columnGap","rowGap","selectedColor","colors","unselectedColor","hoveredColor","onChange","getDerivedStateFromProps","state","selectionDraft","dates","computeDatesMatrix","startTime","minutesInChunk","Math","d","currentDay","h","c","constructor","selectionType","selectionStart","isTouchDragging","linear","selectionSchemes","square","componentDidMount","document","dateCell","passive","componentWillUnmount","getTimeFromTouchEvent","touches","clientY","targetElement","cellTime","endSelection","updateAvailabilityDraft","newSelection","nextDraft","Array","a","b","handleSelectionStartEvent","timeSelected","handleMouseEnterEvent","handleMouseUpEvent","handleTouchMoveEvent","handleTouchEndEvent","time","startHandler","selected","Boolean","refSetter","date","renderFullDateGrid","flattenedDates","numTimes","j","i","dateGridElements","index","dayOfTimes","key","render","el"],"mappings":"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","sourcesContent":["import * as React from 'react'\nimport styled from 'styled-components'\n\n// Import only the methods we need from date-fns in order to keep build size small\nimport addMinutes from 'date-fns/add_minutes'\nimport addHours from 'date-fns/add_hours'\nimport addDays from 'date-fns/add_days'\nimport startOfDay from 'date-fns/start_of_day'\nimport isSameMinute from 'date-fns/is_same_minute'\nimport formatDate from 'date-fns/format'\n\nimport { Text, Subtitle } from './typography'\nimport colors from './colors'\nimport selectionSchemes, { SelectionSchemeType, SelectionType } from './selection-schemes'\n\nconst Wrapper = styled.div`\n  display: flex;\n  align-items: center;\n  width: 100%;\n  user-select: none;\n`\n\nconst Grid = styled.div<{ columns: number; rows: number; columnGap: string; rowGap: string }>`\n  display: grid;\n  grid-template-columns: auto repeat(${props => props.columns}, 1fr);\n  grid-template-rows: auto repeat(${props => props.rows}, 1fr);\n  column-gap: ${props => props.columnGap};\n  row-gap: ${props => props.rowGap};\n  width: 100%;\n`\n\nexport const GridCell = styled.div`\n  place-self: stretch;\n  touch-action: none;\n`\n\nconst DateCell = styled.div<{\n  selected: boolean\n  selectedColor: string\n  unselectedColor: string\n  hoveredColor: string\n}>`\n  width: 100%;\n  height: 25px;\n  background-color: ${props => (props.selected ? props.selectedColor : props.unselectedColor)};\n\n  &:hover {\n    background-color: ${props => props.hoveredColor};\n  }\n`\n\nconst DateLabel = styled(Subtitle)`\n  @media (max-width: 699px) {\n    font-size: 12px;\n  }\n  margin: 0;\n  margin-bottom: 4px;\n`\n\nconst TimeText = styled(Text)`\n  @media (max-width: 699px) {\n    font-size: 10px;\n  }\n  text-align: right;\n  margin: 0;\n  margin-right: 4px;\n`\n\ntype PropsType = {\n  selection: Array<Date>\n  selectionScheme: SelectionSchemeType\n  onChange: (newSelection: Array<Date>) => void\n  startDate: Date\n  numDays: number\n  minTime: number\n  maxTime: number\n  hourlyChunks: number\n  dateFormat: string\n  timeFormat: string\n  columnGap: string\n  rowGap: string\n  unselectedColor: string\n  selectedColor: string\n  hoveredColor: string\n  renderDateCell?: (datetime: Date, selected: boolean, refSetter: (dateCellElement: HTMLElement) => void) => JSX.Element\n  renderTimeLabel?: (time: Date) => JSX.Element\n  renderDateLabel?: (date: Date) => JSX.Element\n}\n\ntype StateType = {\n  // In the case that a user is drag-selecting, we don't want to call this.props.onChange() until they have completed\n  // the drag-select. selectionDraft serves as a temporary copy during drag-selects.\n  selectionDraft: Array<Date>\n  selectionType: SelectionType | null\n  selectionStart: Date | null\n  isTouchDragging: boolean\n  dates: Array<Array<Date>>\n}\n\nexport const preventScroll = (e: TouchEvent) => {\n  e.preventDefault()\n}\n\nexport default class ScheduleSelector extends React.Component<PropsType, StateType> {\n  selectionSchemeHandlers: { [key: string]: (startDate: Date, endDate: Date, foo: Array<Array<Date>>) => Date[] }\n  cellToDate: Map<Element, Date> = new Map()\n  // documentMouseUpHandler: () => void = () => {}\n  // endSelection: () => void = () => {}\n  // handleTouchMoveEvent: (event: React.SyntheticTouchEvent<*>) => void\n  // handleTouchEndEvent: () => void\n  // handleMouseUpEvent: (date: Date) => void\n  // handleMouseEnterEvent: (date: Date) => void\n  // handleSelectionStartEvent: (date: Date) => void\n  gridRef: HTMLElement | null = null\n\n  static defaultProps: Partial<PropsType> = {\n    selection: [],\n    selectionScheme: 'square',\n    numDays: 7,\n    minTime: 9,\n    maxTime: 23,\n    hourlyChunks: 1,\n    startDate: new Date(),\n    timeFormat: 'ha',\n    dateFormat: 'M/D',\n    columnGap: '4px',\n    rowGap: '4px',\n    selectedColor: colors.blue,\n    unselectedColor: colors.paleBlue,\n    hoveredColor: colors.lightBlue,\n    onChange: () => {}\n  }\n\n  static getDerivedStateFromProps(props: PropsType, state: StateType): Partial<StateType> | null {\n    // As long as the user isn't in the process of selecting, allow prop changes to re-populate selection state\n    if (state.selectionStart == null) {\n      return {\n        selectionDraft: [...props.selection],\n        dates: ScheduleSelector.computeDatesMatrix(props)\n      }\n    }\n    return null\n  }\n\n  static computeDatesMatrix(props: PropsType): Array<Array<Date>> {\n    const startTime = startOfDay(props.startDate)\n    const dates: Array<Array<Date>> = []\n    const minutesInChunk = Math.floor(60 / props.hourlyChunks)\n    for (let d = 0; d < props.numDays; d += 1) {\n      const currentDay = []\n      for (let h = props.minTime; h < props.maxTime; h += 1) {\n        for (let c = 0; c < props.hourlyChunks; c += 1) {\n          currentDay.push(addMinutes(addHours(addDays(startTime, d), h), c * minutesInChunk))\n        }\n      }\n      dates.push(currentDay)\n    }\n    return dates\n  }\n\n  constructor(props: PropsType) {\n    super(props)\n\n    this.state = {\n      selectionDraft: [...this.props.selection], // copy it over\n      selectionType: null,\n      selectionStart: null,\n      isTouchDragging: false,\n      dates: ScheduleSelector.computeDatesMatrix(props)\n    }\n\n    this.selectionSchemeHandlers = {\n      linear: selectionSchemes.linear,\n      square: selectionSchemes.square\n    }\n\n    this.endSelection = this.endSelection.bind(this)\n    this.handleMouseUpEvent = this.handleMouseUpEvent.bind(this)\n    this.handleMouseEnterEvent = this.handleMouseEnterEvent.bind(this)\n    this.handleTouchMoveEvent = this.handleTouchMoveEvent.bind(this)\n    this.handleTouchEndEvent = this.handleTouchEndEvent.bind(this)\n    this.handleSelectionStartEvent = this.handleSelectionStartEvent.bind(this)\n  }\n\n  componentDidMount() {\n    // We need to add the endSelection event listener to the document itself in order\n    // to catch the cases where the users ends their mouse-click somewhere besides\n    // the date cells (in which case none of the DateCell's onMouseUp handlers would fire)\n    //\n    // This isn't necessary for touch events since the `touchend` event fires on\n    // the element where the touch/drag started so it's always caught.\n    document.addEventListener('mouseup', this.endSelection)\n\n    // Prevent page scrolling when user is dragging on the date cells\n    this.cellToDate.forEach((value, dateCell) => {\n      if (dateCell && dateCell.addEventListener) {\n        // @ts-ignore\n        dateCell.addEventListener('touchmove', preventScroll, { passive: false })\n      }\n    })\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('mouseup', this.endSelection)\n    this.cellToDate.forEach((value, dateCell) => {\n      if (dateCell && dateCell.removeEventListener) {\n        // @ts-ignore\n        dateCell.removeEventListener('touchmove', preventScroll)\n      }\n    })\n  }\n\n  // Performs a lookup into this.cellToDate to retrieve the Date that corresponds to\n  // the cell where this touch event is right now. Note that this method will only work\n  // if the event is a `touchmove` event since it's the only one that has a `touches` list.\n  getTimeFromTouchEvent(event: React.TouchEvent<any>): Date | null {\n    const { touches } = event\n    if (!touches || touches.length === 0) return null\n    const { clientX, clientY } = touches[0]\n    const targetElement = document.elementFromPoint(clientX, clientY)\n    if (targetElement) {\n      const cellTime = this.cellToDate.get(targetElement)\n      return cellTime ?? null\n    }\n    return null\n  }\n\n  endSelection() {\n    this.props.onChange(this.state.selectionDraft)\n    this.setState({\n      selectionType: null,\n      selectionStart: null\n    })\n  }\n\n  // Given an ending Date, determines all the dates that should be selected in this draft\n  updateAvailabilityDraft(selectionEnd: Date | null, callback?: () => void) {\n    const { selectionType, selectionStart } = this.state\n\n    if (selectionType === null || selectionStart === null) return\n\n    let newSelection: Array<Date> = []\n    if (selectionStart && selectionEnd && selectionType) {\n      newSelection = this.selectionSchemeHandlers[this.props.selectionScheme](\n        selectionStart,\n        selectionEnd,\n        this.state.dates\n      )\n    }\n\n    let nextDraft = [...this.props.selection]\n    if (selectionType === 'add') {\n      nextDraft = Array.from(new Set([...nextDraft, ...newSelection]))\n    } else if (selectionType === 'remove') {\n      nextDraft = nextDraft.filter(a => !newSelection.find(b => isSameMinute(a, b)))\n    }\n\n    this.setState({ selectionDraft: nextDraft }, callback)\n  }\n\n  // Isomorphic (mouse and touch) handler since starting a selection works the same way for both classes of user input\n  handleSelectionStartEvent(startTime: Date) {\n    // Check if the startTime cell is selected/unselected to determine if this drag-select should\n    // add values or remove values\n    const timeSelected = this.props.selection.find(a => isSameMinute(a, startTime))\n    this.setState({\n      selectionType: timeSelected ? 'remove' : 'add',\n      selectionStart: startTime\n    })\n  }\n\n  handleMouseEnterEvent(time: Date) {\n    // Need to update selection draft on mouseup as well in order to catch the cases\n    // where the user just clicks on a single cell (because no mouseenter events fire\n    // in this scenario)\n    this.updateAvailabilityDraft(time)\n  }\n\n  handleMouseUpEvent(time: Date) {\n    this.updateAvailabilityDraft(time)\n    // Don't call this.endSelection() here because the document mouseup handler will do it\n  }\n\n  handleTouchMoveEvent(event: React.TouchEvent) {\n    this.setState({ isTouchDragging: true })\n    const cellTime = this.getTimeFromTouchEvent(event)\n    if (cellTime) {\n      this.updateAvailabilityDraft(cellTime)\n    }\n  }\n\n  handleTouchEndEvent() {\n    if (!this.state.isTouchDragging) {\n      // Going down this branch means the user tapped but didn't drag -- which\n      // means the availability draft hasn't yet been updated (since\n      // handleTouchMoveEvent was never called) so we need to do it now\n      this.updateAvailabilityDraft(null, () => {\n        this.endSelection()\n      })\n    } else {\n      this.endSelection()\n    }\n    this.setState({ isTouchDragging: false })\n  }\n\n  renderDateCellWrapper = (time: Date): JSX.Element => {\n    const startHandler = () => {\n      this.handleSelectionStartEvent(time)\n    }\n\n    const selected = Boolean(this.state.selectionDraft.find(a => isSameMinute(a, time)))\n\n    return (\n      <GridCell\n        className=\"rgdp__grid-cell\"\n        role=\"presentation\"\n        key={time.toISOString()}\n        // Mouse handlers\n        onMouseDown={startHandler}\n        onMouseEnter={() => {\n          this.handleMouseEnterEvent(time)\n        }}\n        onMouseUp={() => {\n          this.handleMouseUpEvent(time)\n        }}\n        // Touch handlers\n        // Since touch events fire on the event where the touch-drag started, there's no point in passing\n        // in the time parameter, instead these handlers will do their job using the default Event\n        // parameters\n        onTouchStart={startHandler}\n        onTouchMove={this.handleTouchMoveEvent}\n        onTouchEnd={this.handleTouchEndEvent}\n      >\n        {this.renderDateCell(time, selected)}\n      </GridCell>\n    )\n  }\n\n  renderDateCell = (time: Date, selected: boolean): JSX.Element => {\n    const refSetter = (dateCell: HTMLElement | null) => {\n      if (dateCell) {\n        this.cellToDate.set(dateCell, time)\n      }\n    }\n    if (this.props.renderDateCell) {\n      return this.props.renderDateCell(time, selected, refSetter)\n    } else {\n      return (\n        <DateCell\n          selected={selected}\n          ref={refSetter}\n          selectedColor={this.props.selectedColor}\n          unselectedColor={this.props.unselectedColor}\n          hoveredColor={this.props.hoveredColor}\n        />\n      )\n    }\n  }\n\n  renderTimeLabel = (time: Date): JSX.Element => {\n    if (this.props.renderTimeLabel) {\n      return this.props.renderTimeLabel(time)\n    } else {\n      return <TimeText>{formatDate(time, this.props.timeFormat)}</TimeText>\n    }\n  }\n\n  renderDateLabel = (date: Date): JSX.Element => {\n    if (this.props.renderDateLabel) {\n      return this.props.renderDateLabel(date)\n    } else {\n      return <DateLabel>{formatDate(date, this.props.dateFormat)}</DateLabel>\n    }\n  }\n\n  renderFullDateGrid(): Array<JSX.Element> {\n    const flattenedDates: Date[] = []\n    const numDays = this.state.dates.length\n    const numTimes = this.state.dates[0].length\n    for (let j = 0; j < numTimes; j += 1) {\n      for (let i = 0; i < numDays; i += 1) {\n        flattenedDates.push(this.state.dates[i][j])\n      }\n    }\n    const dateGridElements = flattenedDates.map(this.renderDateCellWrapper)\n    for (let i = 0; i < numTimes; i += 1) {\n      const index = i * numDays\n      const time = this.state.dates[0][i]\n      // Inject the time label at the start of every row\n      dateGridElements.splice(index + i, 0, this.renderTimeLabel(time))\n    }\n    return [\n      // Empty top left corner\n      <div key=\"topleft\" />,\n      // Top row of dates\n      ...this.state.dates.map((dayOfTimes, index) =>\n        React.cloneElement(this.renderDateLabel(dayOfTimes[0]), { key: `date-${index}` })\n      ),\n      // Every row after that\n      ...dateGridElements.map((element, index) => React.cloneElement(element, { key: `time-${index}` }))\n    ]\n  }\n\n  render(): JSX.Element {\n    return (\n      <Wrapper>\n        <Grid\n          columns={this.state.dates.length}\n          rows={this.state.dates[0].length}\n          columnGap={this.props.columnGap}\n          rowGap={this.props.rowGap}\n          ref={el => {\n            this.gridRef = el\n          }}\n        >\n          {this.renderFullDateGrid()}\n        </Grid>\n      </Wrapper>\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}